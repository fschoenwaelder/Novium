# Authentication Helper

This add-on helps identify and set up authentication handling in ZAP.

The add-on can be used in 2 ways:

- To passively detect authentication features.
- To automatically configure ZAP to handle the authentication features discovered.

The features currently supported are:

- [Authentication Tester](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/auth-tester/)
- [Authentication Request Identification](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/auth-req-id/)
- [Auto-Detect Authentication](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/autodetect-auth/)
- [Browser Based Authentication](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/browser-auth/)
- [Client Script Authentication](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/client-script/)
- [Session Management Identification](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/session-mgmt-id/)
- [Auto-Detect Session Management](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/autodetect-session/)
- [Header Based Session Management](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/session-header/)
- [Verification Identification](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/verification-id/)

This add-on does not currently perform any exploring on its own - it relies upon requests being proxied through ZAP (e.g. via a browser being manually controlled, or integration tests) or requests being generated by ZAP (e.g. via the traditional or AJAX spiders).

You can use the [Authentication Tester](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/auth-tester/) dialog to see if ZAP can automatically configure authentication handling for you target application(s).

You can also configure ZAP to handle authentication automatically via the Automation Framework by supplying just the login URL and the user credentials in the environment:

```
env:
  contexts:
  - name: "target"
    urls:
    - https://example.com
    includePaths: []
    excludePaths: []
    authentication:
      method: "browser"
      parameters:
        loginPageUrl: "https://example.com/login"
      verification:
        method: "autodetect"
    sessionManagement:
      method: "autodetect"
    users:
    - name: "test@example.com"
      credentials:
        username: "test@example.com"
        password: "password123"

```

# Authentication Report - JSON

This is a specialized report which details how authentication handling worked for the given site.

You must specify the site you want the report for otherwise no data will be generated.

This report is designed to be run after attempting to access at least one authenticated URL with the authentication method set up correctly and with valid credentials.

Session handling and verification can be left as “autodetect” - this report will detail how effective that was.

### Sections

| Section | ID |
| --- | --- |
| Summary | summary |
| Automation Framework Environment | afenv |
| Statistics | statistics |
| Diagnostics | diagnostics |
| HTTP Messages for Diagnostics | diagnosticsmessages |
| Local Storage for Diagnostics | diagnosticslocalstorage |
| Screenshots for Diagnostics | diagnosticsscreenshots |
| Session Storage for Diagnostics | diagnosticssessionstorage |
| Web Elements for Diagnostics | diagnosticswebelements |

### Summary

The following summary items are used:

| Key | Passed | Description |
| --- | --- | --- |
| auth.summary.auth | false | Authentication failed |
| auth.summary.auth | true | Authentication appeared to work |
| auth.summary.password | false | Password field not identified |
| auth.summary.password | true | Password field identified |
| auth.summary.session | false | Session Handling not identified |
| auth.summary.session | true | Session Handling identified |
| auth.summary.username | false | Username field not identified |
| auth.summary.username | true | Username field identified |
| auth.summary.verif | false | Verification URL not identified |
| auth.summary.verif | true | Verification URL identified |

### Failure Details

The following failure detail items are used:

| Key | Description |
| --- | --- |
| auth.failure.overall | All authentication elements passed yet authentication was deemed a failure in the end. |
| auth.failure.pass_count | No successful browser logins. |
| auth.failure.session_mgmt | Failed to identify session management. |
| auth.failure.login_failures | One or more failed logins. |
| auth.failure.no_successful_logins | No successful browser logins. |
| auth.failure.verif_ident | Failed to identify verification URL. |

### Automation Framework Environment

This is the [Automation Framework environment](https://www.zaproxy.org/docs/desktop/addons/automation-framework/environment/) that can be used to recreate the context being tested.

If you have set the Session Management or Verification to “autodetect” and ZAP successfully detected them then the environment will have been updated with the values that ZAP has detected.

### Statistics

These are all of the statistics that have been recorded by ZAP.

For more details of what they mean see [https://www.zaproxy.org/docs/internal-statistics/](https://www.zaproxy.org/docs/internal-statistics/)

### Diagnostics

The [Browser Based](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/browser-auth/) and [Client Script](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/client-script/) authentication methods allow to record diagnostic data, which can be included in the Authentication Report, to help diagnose authentication problems.

Diagnostic data can also be recorded with the [Authentication Tester Dialog](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/auth-tester/).

The report will contain an array of diagnostic objects, one for each recorded authentication attempt. The diagnostic objet has the authentication method used, the name of the context and user, and each step performed during the authentication.

```json
	"diagnostics": [
		{
			"created": "0000-00-00T00:00:00.000000Z",
			"authenticationMethod": "Browser-based Authentication",
			"context": "Context Name",
			"user": "User Name",
			"steps": [
				{ … }
			]
		}
	]

```

Each step has at least the URL and the description, it can, optionally, contain also the input element that’s being acted upon (e.g. username field being filled).

```json
	{
		"created": "0000-00-00T00:00:00.000000Z",
		"url": "http://example.com/login/",
		"description": "Auto Fill Username",
		"webElement": {
			"formIndex": 1,
			"attributeType": "text",
			"attributeId": "email",
			"attributeName": "email",
			"attributeValue": "",
			"text": "",
			"displayed": true,
			"enabled": true
		}
		…
	}

```

More data can be included in each step depending on the additional diagnostics sections enabled for the report.

### HTTP Messages for Diagnostics

When this section is enabled the step can, optionally, include HTTP messages that were sent during the step. Each message contains the request/response headers and bodies.

```json
	"messages": [
		{
			"created": "0000-00-00T00:00:00.000000Z",
			"requestHeader": "GET http://example.com/login HTTP/1.1",
			"requestBody": "",
			"responseHeader": "HTTP/1.1 200 OK",
			"responseBody": ""
		}
	]

```

### Local Storage for Diagnostics

When this section is enabled the step can, optionally, include the browser’s local storage.

```json
	"localStorage": [
		{
			"created": "0000-00-00T00:00:00.000000Z",
			"key": "key",
			"value": "value"
		}
	]

```

### Screenshots for Diagnostics

When this section is enabled the step can, optionally, include a screenshot of the page with the image data Base64 encoded.

```json
	"screenshot": "…"

```

### Session Storage for Diagnostics

When this section is enabled the step can, optionally, include the browser’s session storage.

```json
	"sessionStorage": [
		{
			"created": "0000-00-00T00:00:00.000000Z",
			"key": "key",
			"value": "value"
		}
	]

```

### Web Elements for Diagnostics

When this section is enabled the step can, optionally, include all the input elements present in the page.

```json
	"webElements": [
		{
			"formIndex": 0,
			"attributeType": "text",
			"attributeId": "id",
			"attributeName": "name",
			"attributeValue": "",
			"text": "",
			"displayed": true,
			"enabled": true
		}
	]

```

### Sample

```json
{
	"@programName": "ZAP",
	"@version": "Dev Build",
	"@generated": "Mon, 10 Feb 2025 17:27:23",
	"site":  "http:\/\/localhost:9091"
	,"summaryItems": [
		{
			"description": "Authentication appeared to work",
			"passed": true,
			"key": "auth.summary.auth"
		},
		{
			"description": "Username field identified",
			"passed": true,
			"key": "auth.summary.username"
		},
		{
			"description": "Password field identified",
			"passed": true,
			"key": "auth.summary.password"
		},
		{
			"description": "Session Handling identified",
			"passed": true,
			"key": "auth.summary.session"
		},
		{
			"description": "Verification URL identified",
			"passed": true,
			"key": "auth.summary.verif"
		}
	]
	,"failureReasons": [
		{
			"key": "auth.failure.no_successful_logins",
			"description": "No successful logins."
		}
	]
	,"afEnv": "env:\n  contexts:\n  - name: simple-json-bearer-cookie\n    urls:\n    - http:\/\/localhost:9091\/auth\/simple-json-bearer-cookie\n    includePaths:\n    - http:\/\/localhost:9091\/auth\/simple-json-bearer-cookie.*\n    authentication:\n      method: browser\n      parameters:\n        loginPageUrl: http:\/\/localhost:9091\/auth\/simple-json-bearer-cookie\/\n        loginPageWait: 5\n        browserId: firefox-headless\n        steps: []\n      verification:\n        method: poll\n        loggedInRegex: \\Q 200 OK\\E\n        loggedOutRegex: \\Q 403 Forbidden\\E\n        pollFrequency: 0\n        pollUnits: seconds\n        pollUrl: http:\/\/localhost:9091\/auth\/simple-json-bearer-cookie\/user\n        pollPostData: \"\"\n    sessionManagement:\n      method: headers\n      parameters:\n        Authorization: \"Bearer {%json:accesstoken%}\"\n        Cookie: \"token={%json:accesstoken%}\"\n    technology: {}\n    structure: {}\n    users:\n    - name: test\n      credentials:\n        password: password123\n        username: test@test.com\n  parameters: {}\n"
	,"statistics": [
		{
			"key": "stats.auth.browser.foundfields",
			"scope": "site",
			"value": 1
		},
		{
			"key": "stats.auth.browser.passed",
			"scope": "site",
			"value": 1
		},
		{
			"key": "stats.auth.configure.session.header",
			"scope": "global",
			"value": 1
		},
		{
			"key": "stats.auth.configure.verification",
			"scope": "global",
			"value": 1
		},
		{
			"key": "stats.auth.detect.auth.json",
			"scope": "global",
			"value": 5
		},
		{
			"key": "stats.auth.detect.session.accesstoken",
			"scope": "global",
			"value": 5
		},
		{
			"key": "stats.auth.detect.session.authorization",
			"scope": "global",
			"value": 1
		},
		{
			"key": "stats.auth.detect.session.token",
			"scope": "global",
			"value": 7
		},
		{
			"key": "stats.auth.session.set.header",
			"scope": "global",
			"value": 20
		},
		{
			"key": "stats.auth.sessiontoken.accesstoken",
			"scope": "site",
			"value": 9
		},
		{
			"key": "stats.auth.sessiontoken.token",
			"scope": "site",
			"value": 6
		},
		{
			"key": "stats.auth.sessiontokens.max",
			"scope": "global",
			"value": 2
		},
		{
			"key": "stats.auth.state.loggedin",
			"scope": "site",
			"value": 2
		},
		{
			"key": "stats.auth.success",
			"scope": "site",
			"value": 1
		}
	]
}
```

# Authentication Request Identification

This [add-on](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/) includes a passive scan rule which attempts to identify authentication requests.

It identifies authentication requests by the presence of commonly used username and password field names. It also uses commonly used URL segments to identify more likely authentication requests, and uses commonly used registration URL segments to ignore registration requests.

The rule will not attempt to identify very unusual authentication requests - automation is one of the end goals so false negatives (missing unusual authentication requests) are more desirable than false positives (incorrectly identifying an authentication request).

If this rule identifies an authentication request that is part of the context that you have set to use the [Auto-Detect Authentication Method](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/autodetect-auth/) then this rule will update the context to use the authentication method identified.

If an authentication request is not identified then check to make sure it is made to a site which is included in the context.

If it is not then add the site to the context and authenticate again via your browser.

The ‘Other Info’ field is used to report a set of key-value pairs which can be easily parsed. The current keys supported are:

- userParam
- userValue
- passwordParam
- csrfToken

There can potentially be multiple csrfTokens.

The rule will currently identify:

- Form-based authentication requests
- JSON-based authentication requests

If this rule fails to identify one of the above types of authentication requests then you can raise an [issue](https://github.com/zaproxy/zaproxy/issues) with the complete request and response details (having obfuscated any sensitive information) and we will investigate it.

Latest code: [AuthenticationDetectionScanRule.java](https://github.com/zaproxy/zap-extensions/blob/main/addOns/authhelper/src/main/java/org/zaproxy/addon/authhelper/AuthenticationDetectionScanRule.java)

# Authentication Tester Dialog

This dialog allows you to test if ZAP can authenticate and automatically handle the session handling and verification for a site given only the login page and credentials.

## Fields

The following fields are provided:

### Login URL

The URL of the login page. It is mandatory and must start with “http://” or “https://”. The URL does not have to be in the Sites Tree, but must be accessible to ZAP.

### Context

The name of the context which will be configured to handle the authentication. If the context already exists then it will be deleted and recreated.

### Username

The username to use for authentication. The username and password must be valid for the login to work.

### Password

The password to use for authentication. The username and password must be valid for the login to work.

### Browser

The browser to use for authentication. The browser you choose will need to be installed and be able to be launched from ZAP.

### Time to Wait (seconds)

The number of seconds to wait after submitting the login form before closing the browser. If the browser is closed before the application has loaded then ZAP may not be able to identify the session handling or find a suitable verification URL.

### Demo Mode

This just adds 2 second delays between filling in each field and before submitting the form. It has no other effect than making it easier to see what is going on when a non-headless browser is used.

### Record Diagnostics

Enables the recording of diagnostic data during the authentication. Refer to the [Authentication Report](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/auth-report-json/) for more details on the diagnostics.

### Reset Button

The reset button allows you to reset all the fields on the Test tab, and disable all Steps in the Steps tab (steps are only disabled not removed as recreating them might be tedious).

## Results Panel

The results panel show the progress and what has been identified. All elements need to be identified in order for ZAP to be able to automatically handle authentication for this site.

## Diagnostics Tab

The Diagnostics tab will contain a summary of the requests and responses sent and received as part of the authentication testing. It is recommended that you do not perform any other operations in ZAP while testing the authentication otherwise that may result in unrelated messages being recorded.

Only the absolute minimum information is recorded, and host name and parameter values are replaced by safe tokens. You can copy all of the data and review it to make sure it does not include any sensitive data before you share it with us.

Is ZAP fails to detect either the Username or Password field then we will need more details about the login page. If you can share that with us then it will it much easier to debug.

If ZAP detects both of the required fields then please share the data from the diagnostic tab with us - we will hopefully be able to diagnose what’s going wrong with just that information.

# Auto-Detect Authentication

This [add-on](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/) adds a new authentication type which you can use to indicate that the [Authentication Request Identification](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/auth-req-id/) passive scan rule should attempt to configure the Authentication method automatically.

# Auto-Detect Session Management

This [add-on](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/) adds a new Session Management type which you can use to indicate that the [Session Management Request Identification](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/session-mgmt-id/) passive scan rule should attempt to configure the Session Management method automatically.

# Browser Based Authentication

This [add-on](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/) adds a new authentication method which uses a browser to login to the target website.

The authentication method requires the login URL and user credentials to perform the authentication. By default it automatically attempts to find suitable fields for the username and for the password, in the same page and multiple pages (i.e. password field is only made visible when the username has been entered).

The plan is to keep enhancing this authentication method to handle all of the most commonly used login page formats. If it does not work with your application’s login page then please inform the ZAP team via the [ZAP User Group](https://groups.google.com/group/zaproxy-users) giving as many details as possible.

### Authentication Steps

When the authentication method is not able to find suitable fields, or requires extra steps they can be manually specified by the user. The following steps are supported:

| Name | Type | Description |
| --- | --- | --- |
| Auto Steps | `AUTO_STEPS` | Indicates that the authentication method should perform the steps that does by default, to identify and fill the required fields (if not already). This is useful when the authentication method is able to find and submit the fields but other required steps must happen before or after. |
| Click Element | `CLICK` | Clicks a web element, for example, to access the login form or dismiss a popup. |
| Fill Custom Field | `CUSTOM_FIELD` | Fills a custom field with the given value, for example, choose a realm or organisation department in the login form. |
| Fill Password Field | `PASSWORD` | Fills the password in a field, for when no suitable field was automatically identified. |
| Fill TOTP Field | `TOTP_FIELD` | Fills a TOTP field. |
| Fill Username Field | `USERNAME` | Fills the username in a field, for when no suitable field was automatically identified. |
| Send Escape | `ESCAPE` | Sends the escape to the web element, for example, to dismiss a popup. |
| Send Return | `RETURN` | Sends return to the web element, for example, to submit the login form. |

Each step is executed sequentially in the order they are specified. Steps that act on a web element need to be identified with either its CSS Selector or XPath, both of which can be obtained, for example, through browser dev tools. Those steps have a timeout which allow to wait up to the given number of milliseconds for the web element to be shown and be interactable (when the login page takes some time to load).

### Session Identification

The response containing the session token is identified by choosing the first response following a login which contains any of:

- An `Authorization` header
- JSON data with an element called `AccessToken` or `token` - case is ignored

## Automation Framework

Browser Based Authentication can be configured in the environment section of an Automation Framework plan using:

```yaml
      authentication:
        method: "browser"
        parameters:
          loginPageUrl:                # String, the URL of the login page, mandatory
          loginPageWait:               # Int, the time in seconds to wait after the login form has been submitted, default: 5
          browserId:                   # String, Browser Id to use, default: firefox-headless
          diagnostics:                 # Bool, enables the recording of diagnostic data during the authentication. Default: false.
          steps:                       # List of custom steps.
          - description:               # String, the description of the step.
            type:                      # The type of the step, one of: AUTO_STEPS, CLICK, CUSTOM_FIELD, ESCAPE, PASSWORD, RETURN, TOTP_FIELD, USERNAME
            cssSelector:               # String, the CSS Selector to the web element.
            xpath:                     # String, the XPath to the web element.
            value:                     # String, the value to fill in the web element.
            timeout:                   # Int, the number of milliseconds to wait for the web element. Default: 1000

```

Refer to the [Authentication Report](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/auth-report-json/) for more details on the diagnostics.

Note the TOTP data is defined under the user credentials:

```yaml
      credentials:
        username: …
        password: …
        totp:
          secret:          # String, the secret.
          period:          # Int, the period. Default: 30
          digits:          # Int, the number of digits. Default: 6
          algorithm:       # String, the algorithm. Default: SHA1

```

## AJAX Spider Integration

The AJAX Spider will automatically login if a user is specified which is in a context that uses Browser Based Authentication.

Note that this uses the Selenium integration detailed below, so any browsers launched manually will also be logged in if the AJAX spider is performing an authenticated scan using Browser Based Authentication.

## Selenium Integration

Any browsers launched by ZAP can be configured to always first login using the details configured in a context. This is disabled by default.

This feature can be controlled by the following static methods, which are used by the AJAX Spider and can also be called from scripts.

```java
org.zaproxy.addon.authhelper.AuthUtils.enableBrowserAuthentication(Context context, String userName)

```

This method will enable browser authentication whenever a browser is launched, for the given context and user. An exception will be thrown if the context is not configured for browser based authentication or if the user is not found.

```java
org.zaproxy.addon.authhelper.AuthUtils.enableBrowserAuthentication()

```

This method will enable browser authentication whenever a browser is launched. The context is configured for browser based authentication with a valid user will be chosen.

```java
org.zaproxy.addon.authhelper.AuthUtils.disableBrowserAuthentication()

```

This method will disable browser authentication when browser is launched.

Note that due to restrictions in the core:

- Existing contexts are not updated in the GUI if you add or remove this add-on
- Browser Based Authentication cannot be added to a context via the API (unless used with ZAP 2.16.1 or later)

These restrictions will be addressed in a future release.

# Client Script Authentication

This [add-on](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/) adds a new authentication type which uses a browser to login to the target website.

This functionality leverages Zest scripts (which may have been recorded via the ZAP Browser Extension) to login.

## Automation Framework

Client Script Authentication can be configured in the environment section of an Automation Framework plan using:

```yaml
      authentication:
        method: "client"
        parameters:
          script: /path/to/RecordedAuth.zst  # String, the path to the Zest login script
          scriptEngine: Mozilla Zest         # The script engine used for the login script
          diagnostics:                       # Bool, enables the recording of diagnostic data during the authentication. Default: false.

```

Refer to the [Authentication Report](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/auth-report-json/) for more details on the diagnostics.

## Client Spider and AJAX Spider Integration

The Client or AJAX Spider will automatically login if a user is specified which is in a context that uses Client Script Authentication.

Note that this uses the Selenium integration detailed below, so any browsers launched manually will also be logged in if the Client or AJAX spider is performing an authenticated scan using Client Script Authentication.

## Selenium Integration

Any browsers launched by ZAP can be configured to always first login using the details configured in a context.

Note that due to restrictions in the core:

- Existing contexts are not updated in the GUI if you add or remove this add-on
- Client Script Based Authentication cannot be added to a context via the API (unless used with ZAP 2.16.1 or later)

These restrictions will be addressed in a future release.

# Report Templates

This add-on provides the following report templates:

| Name / Link to Details, Screenshot/Sample | ID | Format | Sections | Themes |
| --- | --- | --- | --- | --- |
| [Authentication Report - JSON](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/auth-report-json/) | auth-report-json | JSON | Yes |  |

# Header Based Session Management

This [add-on](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/) adds a new session management type which supports an arbitrary number of headers.

If used in conjunction with [Browser Based Authentication](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/browser-auth/) then it will also maintain all of the cookies set as part of authentication.

The header values can include the following tokens:

|  |  |  |
| --- | --- | --- |
|  | `{%json:path.to.data%}` | JSON authentication response data |
|  | `{%env:env_var%}` | Environmental variable |
|  | `{%script:glob_var%}` | Global script variable |
|  | `{%header:env_var%}` | Authentication response header |
|  | `{%url:key%}` | Authentication URL param |

## Automation Framework

Header Based Session Management can be configured in the environment section of an Automation Framework plan using:

```yaml
      sessionManagement:
        method: "headers"
        parameters:                    #  list of header: value pairs which can include any of the tokens defined above, e.g.
          Authorization: "Bearer: {%json:AuthenticationResult.AccessToken%}"

```

## API

Header Based Session Management can be configured via the ZAP API, using the following parameters:

```
    contextId
    methodName
    methodConfigParams

```

For example:

| contextId | 1 |
| --- | --- |
| methodName | headerBasedSessionManagement |
| methodConfigParams | headers=Authorization:Bearer 8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918 |

When adding Header Based Session Management via the API the `headers` parameter is a string of `header:value`pairs separated by newline characters: `\n`.

Note that due to restrictions in the core:

- Existing contexts are not updated in the GUI if you add or remove this add-on
- Header based Session Management cannot be added to a context via the API (unless used with ZAP 2.16.1 or later)

These restrictions will be addressed in a future release.

# Session Management Identification

This [add-on](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/) includes a passive scan rule which attempts to identify session management methods.

It identifies session management methods by the presence of commonly used session management identifiers and any values specified in Authorization request headers.

The rule will not attempt to identify very unusual session management methods - automation is one of the end goals so false negatives (missing unusual session management methods) are more desirable than false positives (incorrectly identifying a session management method).

If this rule identifies a session management method that is part of the context that you have set to use the [Auto-Detect Session Management Method](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/autodetect-session/) then this rule will update the context to use the session management method identified.

If a session management method is not identified then check to make sure it is made to a site which is included in the context.

If it is not then add the site to the context and authenticate again via your browser.

The ‘Other Info’ field is used to report the set of [Header Based Session Management](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/session-header/) tokens that need to be specified.

The rule will currently identify:

- Header-based session management methods

If this rule fails to identify one of the above method then you can raise an [issue](https://github.com/zaproxy/zaproxy/issues) with the complete request and response details (having obfuscated any sensitive information) and we will investigate it.

# Verification Request Identification

This [add-on](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/) includes a passive scan rule which attempts to identify Verification requests.

Verification requests are the requests that ZAP uses to tell if a session is still valid.

Unlike the other identification scan rules in this add-on, this rule will only raise alerts if you have indicated that you want to use verification auto-detection for a specific context. Due to the way the ZAP 2.12 core works it is not currently possible to add a new Verification Method Type dynamically. Instead you will need to:

- Set the Session Management Method to [Auto-Detect Session Management Method](https://www.zaproxy.org/docs/desktop/addons/authentication-helper/autodetect-session/)
- Set the Verification Strategy to “Poll every Request or Response”
- Not specify a URL to poll

In 2.13+ (and the latest weeklies) it will be possible to set the verification strategy to “Auto-Detect”.

The rule works by identifying requests that behave differently when a valid session management token is supplied, but also behave consistently when a token is supplied and when one is not supplied.

Responses which contain the user name are preferred - this can be the name given to the user in ZAP or the username specified in the credentials.

Unusually for a passive scan rule, this rule actually makes requests rather than just observing them. It needs to do this in order to identify which requests act differently when performed with and without a valid session token. It will only do that if you have enabled it as above.

If the rule identifies a Verification request for a context that does not have one, or a request that is determined to be ‘better’ that the currently identified request then the context will be updated.

If this rule fails to identify a suitable request for your application then you can raise an [issue](https://github.com/zaproxy/zaproxy/issues) with the complete request and response details (having obfuscated any sensitive information) and we will investigate it.

# Automation Framework - delay Job

This job waits for a specified time unless one of a specific set of conditions are met.

It can be used to wait for regression tests being proxied through ZAP in order to explore your application more thoroughly.

It is covered in the video: [ZAP Chat 12 Automation Framework Part 6 - Delays and Active Scan](https://youtu.be/hcftgjz_Vgc).

The time parameter supports the formats `hh:mm:ss`, `mm:ss` and `ss`, so “5” is 5 seconds, “1:30” is one minute and 30 seconds and “2:20:30” is 2 hours, 20 minutes and 30 seconds.

The conditions supported are:

- The creation of the file given by the optional fileName parameter
- Calling the static method: `org.zaproxy.addon.automation.jobs.DelayJob.setEndJob(true);`
- Calling the API end point: `automation / action / endDelayJob`

## YAML

```yaml
  - type: delay                        # Pause the plan for a set period of time or event (file created, static method called, API end point called)
    parameters:
      time:                            # String: The time to wait, format any of ['hh:mm:ss', 'mm:ss', 'ss'], default: 0
      fileName:                        # String: Name of a file which will cause the job to end early if created, default: empty
```

# Automation Framework - exitStatus Job

This job sets [ZAP’s exit code](https://www.zaproxy.org/docs/desktop/addons/automation-framework/#exit-codes) based on scan results. It also allows you to choose which exit values are used. It should typically be the last job in a plan.

If warnLevel or errorLevel are set then the job will report a warning or error if any alerts are raised which have the same risk level or greater.

By default when ZAP is run with the `-cmd` and `-autorun` options then it will exit with a 1 if there are any errors, with a 2 if there are any warnings, and if everything is ok then it will exit with a 0. These values can be overriden by the `*ExitValue` options. The `*ExitValues` can be used together with the warn/errorLevel or completely independently of them.

## YAML

```yaml
  - type: exitStatus                   # Sets the exit code based on scan results
    parameters:
      errorLevel:                      # String: Informational, Low, Medium, High, default: not set
      warnLevel:                       # String: Informational, Low, Medium, High, default: not set
      okExitValue:                     # Integer: Exit value if all ok, default 0
      errorExitValue:                  # Integer: Exit value if there are errors, default 1
      warnExitValue:                   # Integer: Exit value if there are warnings, default 2

```

# Automation Framework - passiveScan-config Job

This job allows you to manage the passive scan configuration.

It is covered in the video: [ZAP Chat 08 Automation Framework Part 2 - Environment](https://youtu.be/1fcpU54N-mA).

The passive scanner runs against all requests and responses that are generated by ZAP or are proxied through it. If you want to configure the passive scan configuration then you should typically do so before running any other jobs. However you can run this job later, or multiple times, if you want different jobs to use different passive scan configurations.

## YAML

```yaml
  - type: passiveScan-config           # Passive scan configuration
    parameters:
      maxAlertsPerRule: 10             # Int: Maximum number of alerts to raise per rule
      scanOnlyInScope: true            # Bool: Only scan URLs in scope (recommended)
      maxBodySizeInBytesToScan:        # Int: Maximum body size to scan, default: 0 - will scan all messages
      enableTags: false                # Bool: Enable passive scan tags, default: false - enabling them can impact performance
      disableAllRules: false           # Bool: If true then will disable all rules before applying the settings in the rules section
    rules:                             # A list of one or more passive scan rules and associated settings which override the defaults
    - id:                              # Int: The rule id as per https://www.zaproxy.org/docs/alerts/
      name:                            # String: The name of the rule for documentation purposes - this is not required or actually used
      threshold:                       # String: The Alert Threshold for this rule, one of Off, Low, Medium, High, default: Medium

```

The job saves the current passive scan configuration when a plan starts and resets it when the plan ends. This is primarily to ensure the scanOnlyInScope setting is not changed - the default is ’true’ for the job but ‘false’ in the GUI.

Note that if you set `disableAllRules` to `true` then they will stay disabled when the plan has finished. Automatically re-enabling them when the plan finishes could result in the rules becoming enabled while the passive scan queue is being processed, for example if the [passiveScan-wait](https://www.zaproxy.org/docs/desktop/addons/automation-framework/job-pscanwait/) job is not used, or if it is used but with the maxDuration option is set.

In versions up to and including 0.16.0 running this job with the default settings would change scanOnlyInScope to ’true’ in the GUI. This has proved confusing as many users use the GUI without setting a scope - when scanOnlyInScope is set to ’true’ and no scope is defined then no passive scan alerts are raised.

# Automation Framework - passiveScan-wait Job

This job waits for the passive scanner to finishing scanning the requests and responses in the current queue. You should typically run this job after the jobs that explore you application, such as the spider jobs or those that import API definitions. If any more requests are sent by ZAP or proxied through ZAP after this job has run then they will be processed by the passive scanner. You can run this job as many times as you need to.

It is covered in the video: [ZAP Chat 12 Automation Framework Part 6 - Delays and Active Scan](https://youtu.be/hcftgjz_Vgc).

## YAML

```yaml
  - type: passiveScan-wait             # Passive scan wait for the passive scanner to finish
    parameters:
      maxDuration: 5                   # Int: The max time to wait for the passive scanner, default: 0 unlimited

```

## Job Data

The following class will be made available to add-ons that provide access to the Job Data such as the Reporting add-on. Note that in this case the data is from the currently enabled Passive Scan rules, regardless of whether they have been used as a result of the Automation Framework, the UI, or the API.

- Key: `passiveScanData`
- Class: [PassiveScanJobResultData](https://github.com/zaproxy/zap-extensions/blob/main/addOns/automation/src/main/java/org/zaproxy/addon/automation/jobs/PassiveScanJobResultData.java)

# Automation Framework - requestor Job

This job sends specifically crafted requests to a target url, with a custom request method and body. The user can also specify an expected response code, against which the actual response is compared, and the user is warned in case it does not match. The user can add additional headers to the request e.g. Authorization Tokens, etc.

It is covered in the video: [ZAP Chat 09 Automation Framework Part 3 - Requests](https://youtu.be/4phnMy9iCPY).

## YAML

```yaml
  - type: requestor                    # Used to send specific requests to targets
    parameters:
      user:                            # String: An optional user to use for authenticated requests, must be defined in the env
    requests:                          # A list of requests to make
      - url:                           # String: A mandatory URL of the request to be made
        name:                          # String: Optional name for the request, for documentation only
        method:                        # String: A non-empty request method, default: GET
        httpVersion:                   # String: The HTTP version to send the request with, default: HTTP/1.1
        headers:                       # An optional list of additional headers to include in the request
            - "header1:value1"
        data:                          # String: Optional data to send in the request body, supports vars
        responseCode:                  # Int: An optional, expected response code against which the actual response code will be matched
```

# Spider Automation Framework Support

This add-on supports the Automation Framework.

## Job: spider

The Spider job runs the Traditional Spider. This is fast but does not handle modern applications as effectively.

It is covered in the video: [ZAP Chat 10 Automation Framework Part 4 - Spidering](https://youtu.be/WivoyVerBCo).

By default this job will spider the first context defined in the environment and so none of the parameters are mandatory.

This job supports monitor tests.

## YAML

```yaml
  - type: spider                       # The traditional spider - fast but doesnt handle modern apps so well
    parameters:
      context:                         # String: Name of the context to spider, default: first context
      user:                            # String: An optional user to use for authentication, must be defined in the env
      url:                             # String: Url to start spidering from, default: first context URL
      maxDuration:                     # Int: The max time in minutes the spider will be allowed to run for, default: 0 unlimited
      maxDepth:                        # Int: The maximum tree depth to explore, default 5
      maxChildren:                     # Int: The maximum number of children to add to each node in the tree
      acceptCookies:                   # Bool: Whether the spider will accept cookies, default: true
      handleODataParametersVisited:    # Bool: Whether the spider will handle OData responses, default: false
      handleParameters:                # Enum [ignore_completely, ignore_value, use_all]: How query string parameters are used when checking if a URI has already been visited, default: use_all
      maxParseSizeBytes:               # Int: The max size of a response that will be parsed, default: 2621440 - 2.5 Mb
      parseComments:                   # Bool: Whether the spider will parse HTML comments in order to find URLs, default: true
      parseGit:                        # Bool: Whether the spider will parse Git metadata in order to find URLs, default: false
      parseDsStore:                    # Bool: Whether the spider will parse .DS_Store files in order to find URLs, default: false
      parseRobotsTxt:                  # Bool: Whether the spider will parse 'robots.txt' files in order to find URLs, default: true
      parseSitemapXml:                 # Bool: Whether the spider will parse 'sitemap.xml' files in order to find URLs, default: true
      parseSVNEntries:                 # Bool: Whether the spider will parse SVN metadata in order to find URLs, default: false
      postForm:                        # Bool: Whether the spider will submit POST forms, default: true
      processForm:                     # Bool: Whether the spider will process forms, default: true
      sendRefererHeader:               # Bool: Whether the spider will send the referer header, default: true
      threadCount:                     # Int: The number of spider threads, default: 2 * Number of available processor cores
      userAgent:                       # String: The user agent to use in requests, default: '' - use the default ZAP one
    tests:
      - name: 'At least 100 URLs found'                 # String: Name of the test, default: statistic + operator + value
        type: 'stats'                                   # String: Type of test, only 'stats' is supported for now
        statistic: 'automation.spider.urls.added'       # String: Name of an integer / long statistic, currently supported: 'automation.spider.urls.added'
        operator: '>='                                  # String ['==', '!=', '>=', '>', '<', '<=']: Operator used for testing
        value: 100                                      # Int: Change this to the number of URLs you expect to find
        onFail: 'info'                                  # String: One of 'warn', 'error', 'info', mandatory
```

# Automation Framework - Options

The following options are available:

## Open Last Plan on Start

If selected then the [Automation tab](https://www.zaproxy.org/docs/desktop/addons/automation-framework/gui/) will automatically load the last plan opened when the GUI starts. This can be useful if you need to regularly use the same plan.

This option has no effect if the desktop GUI is not used.

# Automation Framework - Alert Job Test

Alert tests are supported by the activeScan and passiveScan-wait jobs. These tests can be used to validate the presence/absence of specific alerts in the active/passive scan. It is mandatory for the alerts specified in the plan to have a scanRuleId, against which the generated alerts will always be matched. All other fields describing an alert are optional regexes, and will be matched against only if they are specified.

A job can have tests for multiple alerts, and multiple tests can be created for alerts having the same scanRuleId.

## YAML

```yaml
  jobs:
  - type: activeScan                   # The active scanner - this actively attacks the target so should only be used with permission
    parameters:
      context:                         # String: Name of the context to attack, default: first context
      policy:                          # String: Name of the scan policy to be used, default: Default Policy
      maxRuleDurationInMins:           # Int: The max time in minutes any individual rule will be allowed to run for, default: 0 unlimited
      maxScanDurationInMins:           # Int: The max time in minutes the active scanner will be allowed to run for, default: 0 unlimited
    tests:
      - name: 'test one'                       # Name of the test, optional
        type: alert                            # Specifies that the test is of type 'alert'
        action: passIfPresent/passIfAbsent     # String: The condition (presence/absence) of the alert, default: passIfAbsent
        scanRuleId:                            # Integer: The id of the scanRule which generates the alert, mandatory
        alertName:                             # String: The name of the alert generated, optional
        url: http://www.example.com/path       # String: The url of the request corresponding to the alert generated, optional
        method:                                # String: The method of the request corresponding to the alert generated, optional
        attack:                                # String: The actual attack which generated the alert, optional
        param:                                 # String: The parameter which was modified to generate the alert, optional
        evidence:                              # String: The evidence corresponding to the alert generated, optional
        confidence:                            # String: The confidence of the alert, one of 'False Positive', 'Low', 'Medium', 'High', 'Confirmed', optional
        risk:                                  # String: The risk of the alert, one of 'Informational', 'Low', 'Medium', 'High', optional
        otherInfo:                             # String: Additional information corresponding to the alert, optional
        onFail: 'info'                         # String: One of 'warn', 'error', 'info', mandatory

```

# Automation Framework - Monitor Job Test

Monitor tests are supported by long running jobs, such as [activeScan](https://www.zaproxy.org/docs/desktop/addons/automation-framework/job-ascan/) and spider.

Unlike the other Job Tests, monitor tests run while a job is running. They work in a similar way to [statistic](https://www.zaproxy.org/docs/desktop/addons/automation-framework/test-stats/) tests in that they check a specified statistic, but there is no ‘operator’ - instead the test will fail if the value of the statistic exceeds the given threshold.

Monitor tests can be used to terminate a long running job early, for example if there are too many authentication failures.

An up to date list of the statistics ZAP maintains can be found at [https://www.zaproxy.org/docs/internal-statistics/](https://www.zaproxy.org/docs/internal-statistics/).

A job can have tests for multiple statistics and multiple tests can be created for the same statistic.

Note that monitor tests will function correctly only if in memory statistics have been [enabled](https://www.zaproxy.org/docs/desktop/ui/dialogs/options/stats/#in-memory-statistics-enabled).

## YAML

```yaml
  jobs:
  - type: example
    parameters:
      jobSpecificParam: 'value'
    tests:
      - name: 'test one'                      # Name of the test, optional
        type: monitor                         # Specifies that the test is of type 'monitor'
        statistic: 'stats.addon.something'    # Name of an integer / long statistic
        site:                                 # Name of the site for site specific tests, supports vars
        threshold: 10                         # The threshold at which a statistic fails
        onFail: 'info'                        # String: One of 'warn', 'error', 'info', mandatory
```

# Automation Framework - Statistics Job Test

Statistics-based tests are supported by all add-ons that have an automation job. If there is a relevant statistic used by an add-on, a test can be created for it.

An up to date list of the statistics ZAP maintains can be found at [https://www.zaproxy.org/docs/internal-statistics/](https://www.zaproxy.org/docs/internal-statistics/).

A job can have tests for multiple statistics and multiple tests can be created for the same statistic.

Note that statistics-based tests will function correctly only if in memory statistics have been [enabled](https://www.zaproxy.org/docs/desktop/ui/dialogs/options/stats/#in-memory-statistics-enabled).

## YAML

```yaml
  jobs:
  - type: example
    parameters:
      jobSpecificParam: 'value'
    tests:
      - name: 'test one'                      # Name of the test, optional
        type: stats                           # Specifies that the test is of type 'stats'
        statistic: 'stats.addon.something'    # Name of an integer / long statistic
        site:                                 # Name of the site for site specific tests, supports vars
        operator: '>='                        # One of '==', '!=', '>=', '>', '<', '<='
        value: 10                             # Value to compare statistic against
        onFail: 'info'                        # String: One of 'warn', 'error', 'info', mandatory
```

# Automation Framework - URL Presence Job Test

URL Presence tests are supported by all the jobs. These tests can be used to validate the presence/absence of a URL and it’s specific expressions in the HTTP response/request. The expressions are specified in the YAML file as regular expressions. The test will pass if the URL or the specified expression is found in the response/request depending upon the operator selection.

A job can have tests for multiple expressions, and multiple tests can be created for expressions having the same URL.

## YAML

```yaml
  jobs:
  - type: something
    tests:
      - name: 'test one'                      # Name of the test, optional
        type: url                             # Specifies that the test is of type 'url'
        url: http://www.example.com/path      # String: The URL to be tested.
        operator: 'and'                       # One of 'and', 'or', default is 'or'
        requestHeaderRegex:                   # String: The regular expression to be matched in the request header, optional
        requestBodyRegex:                     # String: The regular expression to be matched in the request body, optional
        responseHeaderRegex:                  # String: The regular expression to be matched in the response header, optional
        responseBodyRegex:                    # String: The regular expression to be matched in the response body, optional
        onFail: 'info'                        # String: One of 'warn', 'error', 'info', mandatory
```

# Automation Framework - Job Outcome Tests

The automation framework supports testing the job outcomes based on conditions that you can set in the YAML file.

The currently supported tests are:

- [alert](https://www.zaproxy.org/docs/desktop/addons/automation-framework/test-alert/) - Alert tests - validate the presence or absence of specified alerts
- [monitor](https://www.zaproxy.org/docs/desktop/addons/automation-framework/test-monitor/) - Monitor tests - allow you to stop long running jobs based on statistic thresholds
- [stats](https://www.zaproxy.org/docs/desktop/addons/automation-framework/test-stats/) - Statistics tests - test any of the statistics maintained by ZAP
- [url](https://www.zaproxy.org/docs/desktop/addons/automation-framework/test-url/) - URL tests - validate the presence/absence of a URL and it’s specific expressions in the HTTP response/request